diff --git a/includes/database/sqlsrv/database.inc b/includes/database/sqlsrv/database.inc
new file mode 100755
index 0000000..e312ac5
--- /dev/null
+++ b/includes/database/sqlsrv/database.inc
@@ -0,0 +1,494 @@
+<?php
+
+/**
+ * @file
+ * Database interface code for Microsoft SQL Server.
+ */
+
+/**
+ * @ingroup database
+ * @{
+ */
+
+include_once DRUPAL_ROOT . '/includes/database/prefetch.inc';
+
+class DatabaseConnection_sqlsrv extends DatabaseConnection {
+
+  public $bypassQueryPreprocess = FALSE;
+
+  /**
+   * Override of DatabaseConnection::driver().
+   *
+   * @status tested
+   */
+  public function driver() {
+    return 'sqlsrv';
+  }
+
+  /**
+   * Override of DatabaseConnection::databaseType().
+   *
+   * @status tested
+   */
+  public function databaseType() {
+    return 'sqlsrv';
+  }
+
+  /**
+   * Override of DatabaseConnection::databaseType().
+   *
+   * @status complete
+   */
+  public function __construct(array $connection_options = array()) {
+    // Store connection options for future reference.
+    $this->connectionOptions = $connection_options;
+
+    // We don't need a specific PDOStatement class here, we simulate it using
+    // DatabaseStatement_sqlsrv below.
+    $this->statementClass = NULL;
+
+    // This driver defaults to transaction support, except if explicitly passed FALSE.
+    $this->transactionSupport = !isset($connection_options['transactions']) || $connection_options['transactions'] !== FALSE;
+
+    // Build the DSN.
+    $options = array(
+      'Server=' . $connection_options['host'] . (!empty($connection_options['port']) ? ',' . $connection_options['port'] : ''),
+      'Database=' . $connection_options['database'],
+    );
+
+    // Launch the connection to the server.
+    parent::__construct('sqlsrv:' . implode(';', $options), $connection_options['username'], $connection_options['password'], array(
+      // We run the statements in "direct mode" because the way PDO prepares
+      // statement in non-direct mode cause temporary tables to be destroyed
+      // at the end of the statement.
+      PDO::SQLSRV_ATTR_DIRECT_QUERY => TRUE,
+      // We ask PDO to perform the placeholders replacement itself because
+      // SQL Server is not able to detect duplicated placeholders in
+      // complex statements.
+      // E.g. This query is going to fail because SQL Server cannot
+      // detect that length1 and length2 are equals.
+      // SELECT SUBSTRING(title, 1, :length1)
+      // FROM node
+      // GROUP BY SUBSTRING(title, 1, :length2);
+      // This is only going to work in PDO 3 but doesn't hurt in PDO 2.
+      PDO::ATTR_EMULATE_PREPARES => TRUE,
+    ));
+
+    $this->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+
+    // Fetch the name of the user-bound schema. It is the schema that SQL Server
+    // will use for non-qualified tables.
+    $this->schema()->defaultSchema = $this->query("SELECT SCHEMA_NAME()")->fetchField();
+  }
+
+  /**
+   * Override of PDO::prepare(): prepare a prefetching database statement.
+   *
+   * @status tested
+   */
+  public function prepare($query, $options = array()) {
+    return new DatabaseStatement_sqlsrv($this, $query, $options);
+  }
+
+  /**
+   * Temporary override of DatabaseConnection::prepareQuery().
+   *
+   * @todo: remove that when DatabaseConnection::prepareQuery() is fixed to call
+   *   $this->prepare() and not parent::prepare().
+   * @status: tested, temporary
+   */
+  public function prepareQuery($query) {
+    $query = $this->prefixTables($query);
+
+    // Call our overriden prepare.
+    return $this->prepare($query);
+  }
+
+  /**
+   * Internal function: prepare a query by calling PDO directly.
+   *
+   * This function has to be public because it is called by other parts of the
+   * database layer, but do not call it directly, as you risk locking down the
+   * PHP process.
+   */
+  public function PDOPrepare($query, array $options = array()) {
+    if (!$this->bypassQueryPreprocess) {
+      $query = $this->preprocessQuery($query);
+    }
+    return parent::prepare($query, $options);
+  }
+
+  /**
+   * This is the original replacement regexp from Microsoft.
+   *
+   * We could probably simplify it a lot because queries only contain
+   * placeholders when we modify them.
+   *
+   * NOTE: removed 'escape' from the list, because it explodes
+   * with LIKE xxx ESCAPE yyy syntax.
+   */
+  const RESERVED_REGEXP = '/\G
+    # Everything that follows a boundary that is not : or _.
+    \b(?<![:\[_])(?:
+      # Any reserved words, followed by a boundary that is not an opening parenthesis.
+      (action|admin|alias|any|are|array|at|begin|boolean|class|commit|contains|current|data|date|day|depth|domain|external|file|full|function|get|go|host|input|language|last|less|local|map|min|module|new|no|object|old|open|operation|parameter|parameters|path|plan|prefix|proc|public|ref|result|returns|role|row|rows|rule|save|search|second|section|session|size|state|statistics|temporary|than|time|timestamp|tran|translate|translation|trim|user|value|variable|view|without)
+      (?!\()
+      |
+      # Or a normal word.
+      ([a-z]+)
+    )\b
+    |
+    \b(
+      [^a-z\'"\\\\]+
+    )\b
+    |
+    (?=[\'"])
+    (
+      "  [^\\\\"] * (?: \\\\. [^\\\\"] *) * "
+      |
+      \' [^\\\\\']* (?: \\\\. [^\\\\\']*) * \'
+    )
+  /Six';
+
+  protected function replaceReservedCallback($matches) {
+    if ($matches[1] !== '') {
+      // Replace reserved words.
+      return '[' . $matches[1] . ']';
+    }
+    else {
+      // Let other value passthru.
+      for ($i = 2; $i < count($matches); $i++) {
+        if ($matches[$i] !== '') {
+          return $matches[$i];
+        }
+      }
+    }
+    return '';
+  }
+
+  public function quoteIdentifier($identifier) {
+    return '[' . $identifier .']';
+  }
+
+  public function escapeField($field) {
+    if (strlen($field) > 0) {
+      return implode('.', array_map(array($this, 'quoteIdentifier'), explode('.', preg_replace('/[^A-Za-z0-9_.]+/', '', $field))));
+    }
+    else {
+      return '';
+    }
+  }
+
+  public function quoteIdentifiers($identifiers) {
+    return array_map(array($this, 'quoteIdentifier'), $identifiers);;
+  }
+
+  /**
+   * Override of DatabaseConnection::queryRange().
+   */
+  public function queryRange($query, $from, $count, array $args = array(), array $options = array()) {
+    $query = $this->addRangeToQuery($query, $from, $count);
+    return $this->query($query, $args, $options);
+  }
+
+  /**
+   * Override of DatabaseConnection::queryTemporary().
+   *
+   * @status tested
+   */
+  public function queryTemporary($query, array $args = array(), array $options = array()) {
+    // Generate a new temporary table name and protect it from prefixing.
+    // SQL Server requires that temporary tables to be non-qualified.
+    $tablename = '#' . $this->generateTemporaryTableName();
+    $prefixes = $this->prefixes;
+    $prefixes[$tablename] = '';
+    $this->setPrefix($prefixes);
+
+    // Replace SELECT xxx FROM table by SELECT xxx INTO #table FROM table.
+    $query = preg_replace('/^SELECT(.*?)FROM/i', 'SELECT$1 INTO ' . $tablename . ' FROM', $query);
+
+    $this->query($query, $args, $options);
+    return $tablename;
+  }
+
+  /**
+   * Internal function: do a manual placeholder replacement for a query.
+   */
+  protected function replacePlaceholders($query, array $args = array()) {
+    // Check if $args is a simple numeric array.
+    if (range(0, count($args) - 1) === array_keys($args)) {
+      // In that case, we have unnamed placeholders.
+      $count = 0;
+      $new_args = array();
+      foreach ($args as $value) {
+        if (is_float($value)) {
+          // Force the conversion to float so as not to loose precision
+          // in the automatic cast.
+          $value = sprintf('%F', $value);
+        }
+        elseif (!is_int($value)) {
+          $value = $this->quote($value);
+        }
+        $query = substr_replace($query, $value, strpos($query, '?'), 1);
+      }
+      $args = $new_args;
+    }
+    else {
+      // Else, this is using named placeholders.
+      foreach ($args as $placeholder => $value) {
+        if (is_float($value)) {
+          // Force the conversion to float so as not to loose precision
+          // in the automatic cast.
+          $value = sprintf('%F', $value);
+        }
+        elseif (!is_int($value)) {
+          $value = $this->quote((string) $value);
+        }
+
+        // PDO allows placeholders to not be prefixed by a colon. See
+        // http://marc.info/?l=php-internals&m=111234321827149&w=2 for
+        // more.
+        if ($placeholder[0] != ':') {
+          $placeholder = ":$placeholder";
+        }
+        // When replacing the placeholders, make sure we search for the
+        // exact placeholder. For example, if searching for
+        // ':db_placeholder_1', do not replace ':db_placeholder_11'.
+        $query = preg_replace('/' . preg_quote($placeholder) . '\b/', $value, $query);
+      }
+    }
+    return $query;
+  }
+
+  /**
+   * Internal function: massage a query to make it compliant with SQL Server.
+   */
+  public function preprocessQuery($query) {
+    // Force quotes around some SQL Server reserved keywords.
+    if (preg_match('/^SELECT/', $query)) {
+      $query = preg_replace_callback(self::RESERVED_REGEXP, array($this, 'replaceReservedCallback'), $query);
+    }
+
+    // Last chance to modify some SQL Server-specific syntax.
+    $replacements = array(
+      // Normalize SAVEPOINT syntax to the SQL Server one.
+      '/^SAVEPOINT (.*)$/' => 'SAVE TRANSACTION $1',
+      '/^ROLLBACK TO SAVEPOINT (.*)$/' => 'ROLLBACK TRANSACTION $1',
+      // SQL Server doesn't need an explicit RELEASE SAVEPOINT.
+      // Run a non-operaiton query to avoid a fatal error
+      // when no query is runned.
+      '/^RELEASE SAVEPOINT (.*)$/' => 'SELECT 1 /* $0 */',
+    );
+    $query = preg_replace(array_keys($replacements), $replacements, $query);
+
+    // Add prefixes to Drupal-specific functions.
+    $functions = array(
+      'SUBSTRING',
+      'SUBSTRING_INDEX',
+      'GREATEST',
+      'CONCAT',
+      'GROUP_CONCAT',
+      'IF',
+      'MD5',
+      'LPAD',
+    );
+    foreach ($functions as $function) {
+      $query = preg_replace('/\b(?<![:.])(' . preg_quote($function) . ')\(/i', $this->schema()->defaultSchema . '.$1(', $query);
+    }
+
+    $replacements = array(
+      'LENGTH' => 'LEN',
+      'POW' => 'POWER',
+    );
+    foreach ($replacements as $function => $replacement) {
+      $query = preg_replace('/\b(?<![:.])(' . preg_quote($function) . ')\(/i', $replacement . '(', $query);
+    }
+
+    // Replace the ANSI concatenation operator with SQL Server poor one.
+    $query = preg_replace('/\|\|/', '+', $query);
+
+    return $query;
+  }
+
+  /**
+   * Internal function: add range options to a query.
+   *
+   * This cannot be set protected because it is used in other parts of the
+   * database engine.
+   *
+   * @status tested
+   */
+  public function addRangeToQuery($query, $from, $count) {
+    if ($from == 0) {
+      // Easy case: just use a TOP query if we don't have to skip any rows.
+      $query = preg_replace('/^\s*SELECT(\s*DISTINCT)?/Dsi', 'SELECT$1 TOP(' . $count . ')', $query);
+    }
+    else {
+      // More complex case: use a TOP query to retrieve $from + $count rows, and
+      // filter out the first $from rows using a window function.
+      $query = preg_replace('/^\s*SELECT(\s*DISTINCT)?/Dsi', 'SELECT$1 TOP(' . ($from + $count) . ') ', $query);
+      $query = '
+        SELECT * FROM (
+          SELECT sub2.*, ROW_NUMBER() OVER(ORDER BY sub2.__line2) AS __line3 FROM (
+            SELECT 1 AS __line2, sub1.* FROM (' . $query . ') AS sub1
+          ) as sub2
+        ) AS sub3
+        WHERE __line3 BETWEEN ' . ($from + 1) . ' AND ' . ($from + $count);
+    }
+
+    return $query;
+  }
+
+  public function mapConditionOperator($operator) {
+    // SQL Server doesn't need special escaping for the \ character in a string
+    // literal, because it uses '' to escape the single quote, not \'. Sadly
+    // PDO doesn't know that and interpret \' as an escaping character. We
+    // use a function call here to be safe.
+    static $specials = array(
+      'LIKE' => array('postfix' => " ESCAPE CHAR(92)"),
+      'NOT LIKE' => array('postfix' => " ESCAPE CHAR(92)"),
+    );
+    return isset($specials[$operator]) ? $specials[$operator] : NULL;
+  }
+
+  /**
+   * Override of DatabaseConnection::nextId().
+   *
+   * @status tested
+   */
+  public function nextId($existing = 0) {
+    // If an exiting value is passed, for its insertion into the sequence table.
+    if ($existing > 0) {
+      try {
+        $this->query('SET IDENTITY_INSERT {sequences} ON; INSERT INTO {sequences} (value) VALUES(:existing); SET IDENTITY_INSERT {sequences} OFF', array(':existing' => $existing));
+      }
+      catch (Exception $e) {
+        // Doesn't matter if this fails, it just means that this value is already
+        // present in the table.
+      }
+    }
+
+    return $this->query('INSERT INTO {sequences} DEFAULT VALUES', array(), array('return' => Database::RETURN_INSERT_ID));
+  }
+
+  /**
+   * Override DatabaseConnection::escapeTable().
+   *
+   * @status needswork
+   */
+  public function escapeTable($table) {
+    // Rescue the # prefix from the escaping.
+    return ($table[0] == '#' ? '#' : '') . preg_replace('/[^A-Za-z0-9_.]+/', '', $table);
+  }
+}
+
+class DatabaseStatement_sqlsrv extends DatabaseStatementPrefetch implements Iterator, DatabaseStatementInterface {
+  protected function getStatement($query, &$args = array()) {
+    return $this->dbh->PDOPrepare($query);
+  }
+
+  public function execute($args = array(), $options = array()) {
+    if (isset($options['fetch'])) {
+      if (is_string($options['fetch'])) {
+        // Default to an object. Note: db fields will be added to the object
+        // before the constructor is run. If you need to assign fields after
+        // the constructor is run, see http://drupal.org/node/315092.
+        $this->setFetchMode(PDO::FETCH_CLASS, $options['fetch']);
+      }
+      else {
+        $this->setFetchMode($options['fetch']);
+      }
+    }
+
+    $logger = $this->dbh->getLogger();
+    if (!empty($logger)) {
+      $query_start = microtime(TRUE);
+    }
+
+    // Prepare the query.
+    $statement = $this->getStatement($this->queryString, $args);
+    if (!$statement) {
+      $this->throwPDOException();
+    }
+
+    $return = $statement->execute($args);
+    if (!$return) {
+      $this->throwPDOException();
+    }
+
+    // Fetch all the data from the reply, in order to release any lock
+    // as soon as possible.
+    $this->rowCount = $statement->rowCount();
+
+    // Bind the binary columns properly.
+    $null = array();
+    for ($i = 0; $i < $statement->columnCount(); $i++) {
+      $meta = $statement->getColumnMeta($i);
+      if ($meta['sqlsrv:decl_type'] == 'varbinary') {
+        $null[$i] = NULL;
+        $statement->bindColumn($i + 1, $null[$i], PDO::PARAM_LOB, 0, PDO::SQLSRV_ENCODING_BINARY);
+      }
+    }
+
+    try {
+      $this->data = $statement->fetchAll(PDO::FETCH_ASSOC);
+    }
+    catch (Exception $e) {
+      $this->data = array();
+    }
+
+    $this->resultRowCount = count($this->data);
+
+    if ($this->resultRowCount) {
+      $this->columnNames = array_keys($this->data[0]);
+    }
+    else {
+      $this->columnNames = array();
+    }
+
+    if (!empty($logger)) {
+      $query_end = microtime(TRUE);
+      $logger->log($this, $args, $query_end - $query_start);
+    }
+
+    // Remove technical columns from the final result set.
+    $droppable_columns = array_flip(isset($options['sqlsrv_drop_columns']) ? $options['sqlsrv_drop_columns'] : array());
+    $dropped_columns = array();
+    foreach ($this->columnNames as $k => $column) {
+      if (substr($column, 0, 2) == '__' || isset($droppable_columns[$column])) {
+        $dropped_columns[] = $column;
+        unset($this->columnNames[$k]);
+      }
+    }
+
+    if ($dropped_columns) {
+      // Renumber columns.
+      $this->columnNames = array_values($this->columnNames);
+
+      foreach ($this->data as $k => $row) {
+        foreach ($dropped_columns as $column) {
+          unset($this->data[$k][$column]);
+        }
+      }
+    }
+
+    // Destroy the statement as soon as possible.
+    unset($statement);
+
+    // Initialize the first row in $this->currentRow.
+    $this->next();
+
+    return $return;
+  }
+}
+
+/**
+ * @} End of "ingroup database".
+ */
+
+/**
+ * Workaround a bug in the database autoloader by defining all the child classes.
+ *
+ * @see http://drupal.org/node/851136
+ */
+class DatabaseTransaction_sqlsrv extends DatabaseTransaction { }
diff --git a/includes/database/sqlsrv/install.inc b/includes/database/sqlsrv/install.inc
new file mode 100755
index 0000000..138d6a4
--- /dev/null
+++ b/includes/database/sqlsrv/install.inc
@@ -0,0 +1,177 @@
+<?php
+
+// Microsoft SQL Server specific install functions
+
+class DatabaseTasks_sqlsrv extends DatabaseTasks {
+
+  protected $pdoDriver = 'sqlsrv';
+
+  public function name() {
+    return 'Microsoft SQL Server';
+  }
+
+  public function __construct() {
+    // Core tasks are using a table without primary key, they need to be
+    // completely rewritten.
+    $this->tasks = array();
+
+    // Create the user-defined functions we need to be Drupal friendly.
+    $this->tasks[] = array(
+      'function' => 'initializeDatabase',
+      'arguments' => array(),
+    );
+  }
+
+  /**
+   * Make SQL Server Drupal friendly.
+   */
+  function initializeDatabase() {
+    $database = Database::getConnection();
+    $database->bypassQueryPreprocess = TRUE;
+    try {
+      // SUBSTRING() function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'SUBSTRING', N'FN') IS NOT NULL BEGIN DROP FUNCTION SUBSTRING END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [SUBSTRING](@op1 nvarchar(max), @op2 sql_variant, @op3 sql_variant) RETURNS nvarchar(max) AS
+BEGIN
+  RETURN CAST(SUBSTRING(CAST(@op1 AS nvarchar(max)), CAST(@op2 AS int), CAST(@op3 AS int)) AS nvarchar(max))
+END
+EOF
+      );
+
+      // SUBSTRING_INDEX() function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'SUBSTRING_INDEX', N'FN') IS NOT NULL BEGIN DROP FUNCTION SUBSTRING_INDEX END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [SUBSTRING_INDEX](@string varchar(8000), @delimiter char(1), @count int) RETURNS varchar(8000) AS
+BEGIN
+  DECLARE @result varchar(8000)
+  DECLARE @end int
+  DECLARE @part int
+  SET @end = 0
+  SET @part = 0
+  IF (@count = 0)
+  BEGIN
+    SET @result = ''
+  END
+  ELSE
+  BEGIN
+    IF (@count < 0)
+    BEGIN
+      SET @string = REVERSE(@string)
+    END
+    WHILE (@part < ABS(@count))
+    BEGIN
+      SET @end = CHARINDEX(@delimiter, @string, @end + 1)
+      IF (@end = 0)
+      BEGIN
+        SET @end = LEN(@string) + 1
+        BREAK
+      END
+      SET @part = @part + 1
+    END
+    SET @result = SUBSTRING(@string, 1, @end - 1)
+    IF (@count < 0)
+    BEGIN
+      SET @result = REVERSE(@result)
+    END
+  END
+  RETURN @result
+END
+EOF
+      );
+
+      // GREATEST() function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'GREATEST', N'FN') IS NOT NULL BEGIN DROP FUNCTION GREATEST END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [GREATEST](@op1 real, @op2 real) RETURNS real AS
+BEGIN
+  DECLARE @result real
+  SET @result = CASE WHEN @op1 >= @op2 THEN @op1 ELSE @op2 END
+  RETURN @result
+END
+EOF
+      );
+
+      // CONCAT() function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'CONCAT', N'FN') IS NOT NULL BEGIN DROP FUNCTION CONCAT END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [CONCAT](@op1 sql_variant, @op2 sql_variant) RETURNS nvarchar(4000) AS
+BEGIN
+  DECLARE @result nvarchar(4000)
+  SET @result = CAST(@op1 AS nvarchar(4000)) + CAST(@op2 AS nvarchar(4000))
+  RETURN @result
+END
+EOF
+      );
+
+      // IF(expr1, expr2, expr3) function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'IF', N'FN') IS NOT NULL BEGIN DROP FUNCTION [IF] END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [IF](@expr1 sql_variant, @expr2 sql_variant, @expr3 sql_variant) RETURNS sql_variant AS
+BEGIN
+  DECLARE @result sql_variant
+  SET @result = CASE WHEN CAST(@expr1 AS int) != 0 THEN @expr2 ELSE @expr3 END
+  RETURN @result
+END
+EOF
+      );
+
+      // MD5(expr1) function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'MD5', N'FN') IS NOT NULL BEGIN DROP FUNCTION [MD5] END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [MD5](@value varchar(255)) RETURNS varchar(32) AS
+BEGIN
+  RETURN SUBSTRING(sys.fn_sqlvarbasetostr(HASHBYTES('MD5', @value)),3,32);
+END
+EOF
+      );
+
+      // LPAD(@str, @len, @padstr) function.
+      $database->query(<<< EOF
+IF OBJECT_ID (N'LPAD', N'FN') IS NOT NULL BEGIN DROP FUNCTION [LPAD] END
+EOF
+      );
+      $database->query(<<< EOF
+CREATE FUNCTION [dbo].[LPAD](@str nvarchar(max), @len int, @padstr nvarchar(max)) RETURNS nvarchar(4000) AS
+BEGIN
+  RETURN left(@str + replicate(@padstr,@len),@len);
+END
+EOF
+      );
+
+      $database->bypassQueryPreprocess = FALSE;
+    }
+    catch (Exception $e) {
+      $this->fail(st('Drupal could not be correctly setup with the existing database. Revise any errors.'));
+    }
+  }
+
+  // Modify the default options form to allow Windows authentication.
+  public function getFormOptions($database) {
+    $form = parent::getFormOptions($database);
+    // Make username not required.
+    $form['username']['#required'] = FALSE;
+    // Add a description for about leaving username blank.
+    $form['username']['#description'] = t('Leave username (and password) blank to use Windows authentication.');
+
+    return $form;
+  }
+}
diff --git a/includes/database/sqlsrv/query.inc b/includes/database/sqlsrv/query.inc
new file mode 100755
index 0000000..73ce681
--- /dev/null
+++ b/includes/database/sqlsrv/query.inc
@@ -0,0 +1,328 @@
+<?php
+
+/**
+ * SQL Server-specific implementation of INSERT.
+ *
+ * SQL Server doesn't supports multi-insert queries, and needs special handling for
+ * binary columns.
+ */
+class InsertQuery_sqlsrv extends InsertQuery {
+
+  public function execute() {
+    if (!$this->preExecute()) {
+      return NULL;
+    }
+
+    // Fetch the list of blobs and sequences used on that table.
+    $columnInformation = $this->connection->schema()->queryColumnInformation($this->table);
+
+    // Find out if there is an identity field set in this insert.
+    foreach ($this->insertFields as $field) {
+      if (isset($columnInformation['identities'][$field])) {
+        $this->setIdentity = TRUE;
+      }
+    }
+
+    // Each insert happens in its own query. However, we wrap it in a transaction
+    // so that it is atomic where possible.
+    if (empty($this->queryOptions['sqlsrv_skip_transactions'])) {
+      $transaction = $this->connection->startTransaction();
+    }
+
+    if (!empty($this->fromQuery)) {
+      // Re-initialize the values array so that we can re-use this query.
+      $this->insertValues = array();
+
+      $stmt = $this->connection->PDOPrepare($this->connection->prefixTables((string) $this));
+      // Handle the case of SELECT-based INSERT queries first.
+      $values = $this->fromQuery->getArguments();
+      foreach ($values as $key => $value) {
+        $stmt->bindParam($key, $values[$key]);
+      }
+
+      try {
+        $stmt->execute();
+      }
+      catch (Exception $e) {
+        // This INSERT query failed, rollback everything if we started a transaction earlier.
+        if (!empty($transaction)) {
+          $transaction->rollback();
+        }
+        // Rethrow the exception.
+        throw $e;
+      }
+
+      return $this->connection->lastInsertId();
+    }
+
+    // Handle the case of full-default queries.
+    if (empty($this->fromQuery) && (empty($this->insertFields) || empty($this->insertValues))) {
+      // Re-initialize the values array so that we can re-use this query.
+      $this->insertValues = array();
+
+      $stmt = $this->connection->PDOPrepare($this->connection->prefixTables('INSERT INTO {' . $this->table . '} DEFAULT VALUES'));
+      try {
+        $stmt->execute();
+      }
+      catch (Exception $e) {
+        // This INSERT query failed, rollback everything if we started a transaction earlier.
+        if (!empty($transaction)) {
+          $transaction->rollback();
+        }
+        // Rethrow the exception.
+        throw $e;
+      }
+
+      return $this->connection->lastInsertId();
+    }
+
+    $query = (string) $this;
+    $stmt = $this->connection->PDOPrepare($this->connection->prefixTables($query));
+
+    // We use this array to store references to the blob handles.
+    // This is necessary because the PDO will otherwise messes up with references.
+    $data_values = array();
+
+    foreach ($this->insertValues as $insert_index => $insert_values) {
+      $max_placeholder = 0;
+      foreach ($this->insertFields as $field_index => $field) {
+        $placeholder = ':db_insert' . $max_placeholder++;
+        if (isset($columnInformation['blobs'][$field])) {
+          $data_values[$placeholder . $insert_index] = fopen('php://memory', 'a');
+          fwrite($data_values[$placeholder . $insert_index], $insert_values[$field_index]);
+          rewind($data_values[$placeholder . $insert_index]);
+
+          $stmt->bindParam($placeholder, $data_values[$placeholder . $insert_index], PDO::PARAM_LOB, 0, PDO::SQLSRV_ENCODING_BINARY);
+        }
+        else {
+          $data_values[$placeholder . $insert_index] = $insert_values[$field_index];
+          $stmt->bindParam($placeholder, $data_values[$placeholder . $insert_index]);
+        }
+      }
+
+      try {
+        $stmt->execute();
+      }
+      catch (Exception $e) {
+        // This INSERT query failed, rollback everything if we started a transaction earlier.
+        if (!empty($transaction)) {
+          $transaction->rollback();
+        }
+        // Rethrow the exception.
+        throw $e;
+      }
+
+      $last_insert_id = $this->connection->lastInsertId();
+    }
+
+    // Re-initialize the values array so that we can re-use this query.
+    $this->insertValues = array();
+
+    return $last_insert_id;
+  }
+
+  public function __toString() {
+    // Create a sanitized comment string to prepend to the query.
+    $prefix = $this->connection->makeComment($this->comments);
+
+    // Enable direct insertion to identity columns if necessary.
+    if (!empty($this->setIdentity)) {
+      $prefix .= 'SET IDENTITY_INSERT {' . $this->table . '} ON;';
+    }
+
+    // If we're selecting from a SelectQuery, finish building the query and
+    // pass it back, as any remaining options are irrelevant.
+    if (!empty($this->fromQuery)) {
+      return $prefix . "INSERT INTO {" . $this->table . '} (' . implode(', ', $this->connection->quoteIdentifiers($this->insertFields)) . ') ' . $this->fromQuery;
+    }
+
+    // Build the list of placeholders.
+    $placeholders = array();
+    for ($i = 0; $i < count($this->insertFields); ++$i) {
+      $placeholders[] = ':db_insert' . $i;
+    }
+
+    return $prefix . 'INSERT INTO {' . $this->table . '} (' . implode(', ', $this->connection->quoteIdentifiers($this->insertFields)) . ') VALUES (' . implode(', ', $placeholders) . ')';
+  }
+}
+
+/**
+ * SQL Server-specific implementation of UPDATE.
+ *
+ * The specific parts are:
+ *  - SQL Server returns the number of matched rows to an UPDATE, and Drupal
+ *    requires the number of affected rows to be returned.
+ *  - SQL Server requires a special handling for the blobs.
+ */
+class UpdateQuery_sqlsrv extends UpdateQuery {
+  /**
+   * Rewrite the query not to select non-affected rows.
+   *
+   * A query like this one:
+   *   UPDATE test SET col1 = 'newcol1', col2 = 'newcol2' WHERE tid = 1
+   * will become:
+   *   UPDATE test SET col1 = 'newcol1', col2 = 'newcol2' WHERE tid = 1 AND (col1 <> 'newcol1' OR col2 <> 'newcol2')
+   */
+  protected function excludeNonAffectedRows() {
+    if (!empty($this->queryOptions['sqlsrv_return_matched_rows'])) {
+      return;
+    }
+
+    // Get the fields used in the update query.
+    $fields = $this->expressionFields + $this->fields;
+
+    // Add the inverse of the fields to the condition.
+    $condition = new DatabaseCondition('OR');
+    foreach ($fields as $field => $data) {
+      if (is_array($data)) {
+        // The field is an expression.
+        // Re-bind the placeholders.
+        $expression = $data['expression'];
+        $arguments = array();
+        if (!empty($data['arguments'])) {
+          foreach ($data['arguments'] as $placeholder => $value) {
+            $new_placeholder = ':db_exclude_placeholder_' . $this->nextPlaceholder();
+            $expression = str_replace($placeholder, $new_placeholder, $expression);
+            $arguments[$new_placeholder] = $value;
+          }
+        }
+        $condition->where($field . ' <> ' . $expression, $arguments);
+        $condition->isNull($field);
+      }
+      elseif (!isset($data)) {
+        // The field will be set to NULL.
+        $condition->isNotNull($field);
+      }
+      else {
+        $condition->condition($field, $data, '<>');
+        $condition->isNull($field);
+      }
+    }
+    if (count($condition)) {
+      // Workaround for a bug in the base MergeQuery implementation:
+      // a DatabaseCondition object is reused without being re-compiled,
+      // leading to duplicate placeholders.
+      $this->nextPlaceholder = 1000000;
+      $this->condition($condition);
+    }
+  }
+
+  public function execute() {
+    // Rewrite the query to exclude the non-affected rows.
+    $this->excludeNonAffectedRows();
+
+    // Now perform the special handling for BLOB fields.
+    $max_placeholder = 0;
+
+    // Because we filter $fields the same way here and in __toString(), the
+    // placeholders will all match up properly.
+    $stmt = $this->connection->PDOPrepare($this->connection->prefixTables((string)$this));
+
+    // Fetch the list of blobs and sequences used on that table.
+    $columnInformation = $this->connection->schema()->queryColumnInformation($this->table);
+
+    // Expressions take priority over literal fields, so we process those first
+    // and remove any literal fields that conflict.
+    $fields = $this->fields;
+    $expression_fields = array();
+    foreach ($this->expressionFields as $field => $data) {
+      if (!empty($data['arguments'])) {
+        foreach ($data['arguments'] as $placeholder => $argument) {
+          // We assume that an expression will never happen on a BLOB field,
+          // which is a fairly safe assumption to make since in most cases
+          // it would be an invalid query anyway.
+          $stmt->bindParam($placeholder, $data['arguments'][$placeholder]);
+        }
+      }
+      unset($fields[$field]);
+    }
+
+    // We use this array to store references to the blob handles.
+    // This is necessary because the PDO will otherwise messes up with references.
+    $blobs = array();
+    $blob_count = 0;
+
+    foreach ($fields as $field => $value) {
+      $placeholder = ':db_update_placeholder_' . ($max_placeholder++);
+
+      if (isset($columnInformation['blobs'][$field])) {
+        $blobs[$blob_count] = fopen('php://memory', 'a');
+        fwrite($blobs[$blob_count], $value);
+        rewind($blobs[$blob_count]);
+        $stmt->bindParam($placeholder, $blobs[$blob_count], PDO::PARAM_LOB, 0, PDO::SQLSRV_ENCODING_BINARY);
+        $blob_count++;
+      }
+      else {
+        $stmt->bindParam($placeholder, $fields[$field]);
+      }
+    }
+
+    if (count($this->condition)) {
+      $this->condition->compile($this->connection, $this);
+
+      $arguments = $this->condition->arguments();
+      foreach ($arguments as $placeholder => $value) {
+        $stmt->bindParam($placeholder, $arguments[$placeholder]);
+      }
+    }
+
+    $options = $this->queryOptions;
+    $options['already_prepared'] = TRUE;
+    $stmt->execute();
+
+    return $stmt->rowCount();
+  }
+
+  public function __toString() {
+    // Create a sanitized comment string to prepend to the query.
+    $prefix = $this->connection->makeComment($this->comments);
+
+    // Expressions take priority over literal fields, so we process those first
+    // and remove any literal fields that conflict.
+    $fields = $this->fields;
+    $update_fields = array();
+    foreach ($this->expressionFields as $field => $data) {
+      $update_fields[] = $this->connection->quoteIdentifier($field) . '=' . $data['expression'];
+      unset($fields[$field]);
+    }
+
+    $max_placeholder = 0;
+    foreach ($fields as $field => $value) {
+      $update_fields[] = $this->connection->quoteIdentifier($field) . '=:db_update_placeholder_' . ($max_placeholder++);
+    }
+
+    $query = $prefix . 'UPDATE {' . $this->connection->escapeTable($this->table) . '} SET ' . implode(', ', $update_fields);
+
+    if (count($this->condition)) {
+      $this->condition->compile($this->connection, $this);
+      // There is an implicit string cast on $this->condition.
+      $query .= "\nWHERE " . $this->condition;
+    }
+
+    return $query;
+  }
+}
+
+/**
+ * SQL Server-specific implementation of TRUNCATE.
+ */
+class TruncateQuery_sqlsrv extends TruncateQuery {
+  public function __toString() {
+    // Create a sanitized comment string to prepend to the query.
+    $prefix = $this->connection->makeComment($this->comments);
+
+    return $prefix . 'TRUNCATE TABLE {' . $this->connection->escapeTable($this->table) . '} ';
+  }
+}
+
+/**
+ * SQL Server-specific implementation of the MERGE operation.
+ */
+class MergeQuery_sqlsrv extends MergeQuery {
+  public function execute() {
+    // We don't need INSERT or UPDATE queries to trigger additional transactions.
+    $this->queryOptions['sqlsrv_skip_transactions'] = TRUE;
+
+    return parent::execute();
+  }
+}
diff --git a/includes/database/sqlsrv/schema.inc b/includes/database/sqlsrv/schema.inc
new file mode 100755
index 0000000..015eed7
--- /dev/null
+++ b/includes/database/sqlsrv/schema.inc
@@ -0,0 +1,798 @@
+<?php
+
+/**
+ * @file
+ * Database schema code for Microsoft SQL Server database servers.
+ */
+
+/**
+ * @ingroup schemaapi
+ * @{
+ */
+
+class DatabaseSchema_sqlsrv extends DatabaseSchema {
+
+  /**
+   * Default schema for SQL Server databases.
+   */
+  public $defaultSchema = 'dbo';
+
+  protected $additionalColumnInformation = NULL;
+
+  /**
+   * Database introspection: fetch technical information about a table.
+   */
+  public function queryColumnInformation($table) {
+    $table_info = $this->getPrefixInfo($table);
+    $key = $table_info['schema'] . '.' . $table_info['table'];
+
+    if (!isset($this->additionalColumnInformation[$key])) {
+      $this->additionalColumnInformation[$key] = array();
+
+      // Don't use {} around information_schema.columns table.
+      $result = $this->connection->query("SELECT name AS column_name FROM sys.columns WHERE object_id = OBJECT_ID(:table) AND user_type_id = TYPE_ID(:type)", array(':table' => $table_info['schema'] . '.' . $table_info['table'], ':type' => 'varbinary'));
+      foreach ($result as $column) {
+        $this->additionalColumnInformation[$key]['blobs'][$column->column_name] = TRUE;
+      }
+
+      // Don't use {} around system tables.
+      $result = $this->connection->query('SELECT name column_name FROM sys.identity_columns WHERE object_id = OBJECT_ID(:table)', array(':table' => $table_info['schema'] . '.' . $table_info['table']));
+      foreach ($result as $column) {
+        $this->additionalColumnInformation[$key]['identities'][$column->column_name] = TRUE;
+      }
+    }
+
+    return $this->additionalColumnInformation[$key];
+  }
+
+  // TODO: implement the same for alter table and add/remove fields.
+  public function createTable($name, $table) {
+    // Reset the additional column information because the schema changed.
+    $this->additionalColumnInformation = NULL;
+
+    if ($this->tableExists($name)) {
+      throw new DatabaseSchemaObjectExistsException(t('Table %name already exists.', array('%name' => $name)));
+    }
+
+    // Build the table and its unique keys in a transaction, and fail the whole
+    // creation in case of an error.
+    $transaction = $this->connection->startTransaction();
+    try {
+      $this->connection->query($this->createTableSql($name, $table));
+
+      if (isset($table['unique keys']) && is_array($table['unique keys'])) {
+        foreach ($table['unique keys'] as $key_name => $key) {
+          $this->addUniqueKey($name, $key_name, $key);
+        }
+      }
+    }
+    catch (Exception $e) {
+      $transaction->rollback();
+      throw $e;
+    }
+
+    // Everything went well, commit the transaction.
+    unset($transaction);
+
+    // Create the indexes but ignore any error during the creation. We do that
+    // do avoid pulling the carpet under modules that try to implement indexes
+    // with invalid data types (long columns), before we come up with a better
+    // solution.
+    if (isset($table['indexes']) && is_array($table['indexes'])) {
+      foreach ($table['indexes'] as $key_name => $key) {
+        try {
+          $this->connection->query($this->createIndexSql($name, $key_name, $key));
+        }
+        catch (Exception $e) {
+          // Log the exception but do not rollback the transaction.
+          watchdog_exception('database', $e);
+        }
+      }
+    }
+
+  }
+
+  public function tableExists($table) {
+    try {
+      $this->connection->query('SELECT TOP(1) 1 FROM {' . $table . '}');
+      return TRUE;
+    }
+    catch (PDOException $e) {
+      return FALSE;
+    }
+  }
+
+  /**
+   * Generate SQL to create a new table from a Drupal schema definition.
+   *
+   * @param $name
+   *   The name of the table to create.
+   * @param $table
+   *   A Schema API table definition array.
+   * @return
+   *   The SQL statement to create the table.
+   */
+  protected function createTableSql($name, $table) {
+    $sql_fields = array();
+    foreach ($table['fields'] as $field_name => $field) {
+      $sql_fields[] = $this->createFieldSql($name, $field_name, $this->processField($field));
+    }
+
+    // If the table has no primary key, create one for us.
+    // TODO: only necessary on Azure.
+    if (isset($table['primary key']) && is_array($table['primary key'])) {
+      $sql_fields[] = 'CONSTRAINT {' . $name . '}_pkey PRIMARY KEY CLUSTERED (' . implode(', ', $this->connection->quoteIdentifiers($table['primary key'])) . ')';
+    }
+    else {
+      $sql_fields[] = '__pk UNIQUEIDENTIFIER DEFAULT NEWID() NOT NULL';
+      $sql_fields[] = 'CONSTRAINT {' . $name . '}_pkey_technical PRIMARY KEY CLUSTERED (__pk)';
+    }
+
+    $sql = "CREATE TABLE [{" . $name . "}] (\n\t";
+    $sql .= implode(",\n\t", $sql_fields);
+    $sql .= "\n)";
+    return $sql;
+  }
+
+  /**
+   * Create an SQL string for a field to be used in table creation or
+   * alteration.
+   *
+   * Before passing a field out of a schema definition into this
+   * function it has to be processed by _db_process_field().
+   *
+   * @param $table
+   *    The name of the table.
+   * @param $name
+   *    Name of the field.
+   * @param $spec
+   *    The field specification, as per the schema data structure format.
+   */
+  protected function createFieldSql($table, $name, $spec, $skip_checks = FALSE) {
+    $sql = $this->connection->quoteIdentifier($name) . ' ' . $spec['sqlsrv_type'];
+
+    if (in_array($spec['sqlsrv_type'], array('char', 'varchar', 'text', 'nchar', 'nvarchar', 'ntext')) && !empty($spec['length'])) {
+      $sql .= '(' . $spec['length'] . ')';
+    }
+    elseif (in_array($spec['sqlsrv_type'], array('numeric', 'decimal')) && isset($spec['precision']) && isset($spec['scale'])) {
+      $sql .= '(' . $spec['precision'] . ', ' . $spec['scale'] . ')';
+    }
+
+    if (isset($spec['not null']) && $spec['not null']) {
+      $sql .= ' NOT NULL';
+    }
+
+    if (!$skip_checks) {
+      if (isset($spec['default'])) {
+        $default = is_string($spec['default']) ? "'" . addslashes($spec['default']) . "'" : $spec['default'];
+        $sql .= ' CONSTRAINT {' . $table . '}_' . $name . '_df DEFAULT ' . $default;
+      }
+      if (!empty($spec['identity'])) {
+        $sql .= ' IDENTITY';
+      }
+      if (!empty($spec['unsigned'])) {
+        $sql .= ' CHECK (' . $this->connection->quoteIdentifier($name) . ' >= 0)';
+      }
+    }
+    return $sql;
+  }
+
+  /**
+   * Return a list of columns for an index definition.
+   */
+  protected function createKeySql($fields) {
+    $ret = array();
+    foreach ($fields as $field) {
+      if (is_array($field)) {
+        $ret[] = $field[0];
+      }
+      else {
+        $ret[] = $field;
+      }
+    }
+    return implode(', ', $ret);
+  }
+
+  /**
+   * Return the SQL Statement to create an index.
+   */
+  protected function createIndexSql($table, $name, $fields) {
+    // Here we need to create a computed PERSISTENT column, and index that, when
+    // the type is not allowed in an index.
+    return 'CREATE INDEX ' . $name . '_idx ON [{' . $table . '}] (' . $this->createKeySql($fields) . ')';
+  }
+
+  /**
+   * Set database-engine specific properties for a field.
+   *
+   * @param $field
+   *   A field description array, as specified in the schema documentation.
+   */
+  protected function processField($field) {
+    if (!isset($field['size'])) {
+      $field['size'] = 'normal';
+    }
+    // Set the correct database-engine specific datatype.
+    if (!isset($field['sqlsrv_type'])) {
+      $map = $this->getFieldTypeMap();
+      $field['sqlsrv_type'] = $map[$field['type'] . ':' . $field['size']];
+    }
+    if ($field['type'] == 'serial') {
+      $field['identity'] = TRUE;
+    }
+    return $field;
+  }
+
+  /**
+   * This maps a generic data type in combination with its data size
+   * to the engine-specific data type.
+   */
+  function getFieldTypeMap() {
+    // Put :normal last so it gets preserved by array_flip.  This makes
+    // it much easier for modules (such as schema.module) to map
+    // database types back into schema types.
+    return array(
+      'varchar:normal' => 'nvarchar',
+      'char:normal' => 'nchar',
+
+      'text:tiny' => 'nvarchar(max)',
+      'text:small' => 'nvarchar(max)',
+      'text:medium' => 'nvarchar(max)',
+      'text:big' => 'nvarchar(max)',
+      'text:normal' => 'nvarchar(max)',
+
+      'serial:tiny'     => 'smallint',
+      'serial:small'    => 'smallint',
+      'serial:medium'   => 'int',
+      'serial:big'      => 'bigint',
+      'serial:normal'   => 'int',
+
+      'int:tiny' => 'smallint',
+      'int:small' => 'smallint',
+      'int:medium' => 'int',
+      'int:big' => 'bigint',
+      'int:normal' => 'int',
+
+      'float:tiny' => 'real',
+      'float:small' => 'real',
+      'float:medium' => 'real',
+      'float:big' => 'float(53)',
+      'float:normal' => 'real',
+
+      'numeric:normal' => 'numeric',
+
+      'blob:big' => 'varbinary(max)',
+      'blob:normal' => 'varbinary(max)',
+
+      'datetime:normal' => 'timestamp',
+      'date:normal'     => 'date',
+      'datetime:normal' => 'datetime2(0)',
+      'time:normal'     => 'time(0)',
+    );
+  }
+
+  /**
+   * Override DatabaseSchema::renameTable().
+   *
+   * @status complete
+   */
+  public function renameTable($table, $new_name) {
+    if (!$this->tableExists($table)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot rename %table to %table_new: table %table doesn't exist.", array('%table' => $table, '%table_new' => $new_name)));
+    }
+    if ($this->tableExists($new_name)) {
+      throw new DatabaseSchemaObjectExistsException(t("Cannot rename %table to %table_new: table %table_new already exists.", array('%table' => $table, '%table_new' => $new_name)));
+    }
+
+    $old_table_info = $this->getPrefixInfo($table);
+    $new_table_info = $this->getPrefixInfo($new_name);
+
+    // We don't support renaming tables across schemas (yet).
+    if ($old_table_info['schema'] != $new_table_info['schema']) {
+      throw new PDOException(t('Cannot rename a table across schema.'));
+    }
+
+    $this->connection->query('EXEC sp_rename :old, :new', array(
+      ':old' => $old_table_info['schema'] . '.' . $old_table_info['table'],
+      ':new' => $new_table_info['table'],
+    ));
+
+    // Constraint names are global in SQL Server, so we need to rename them
+    // when renaming the table. For some strange reason, indexes are local to
+    // a table.
+    $objects = $this->connection->query('SELECT name FROM sys.objects WHERE parent_object_id = OBJECT_ID(:table)', array(':table' => $new_table_info['schema'] . '.' . $new_table_info['table']));
+    foreach ($objects as $object) {
+      if (preg_match('/^' . preg_quote($old_table_info['table']) . '_(.*)$/', $object->name, $matches)) {
+        $this->connection->query('EXEC sp_rename :old, :new, :type', array(
+          ':old' => $old_table_info['schema'] . '.' . $object->name,
+          ':new' => $new_table_info['table'] . '_' . $matches[1],
+          ':type' => 'OBJECT',
+        ));
+      }
+    }
+  }
+
+  /**
+   * Override DatabaseSchema::dropTable().
+   *
+   * @status tested
+   */
+  public function dropTable($table) {
+    if (!$this->tableExists($table)) {
+      return FALSE;
+    }
+
+    $this->connection->query('DROP TABLE {' . $table . '}');
+    return TRUE;
+  }
+
+  public function fieldExists($table, $field) {
+    try {
+      $this->connection->query('SELECT TOP(1) [' . $field . '] FROM {' . $table . '}');
+      return TRUE;
+    }
+    catch (PDOException $e) {
+      return FALSE;
+    }
+  }
+
+  /**
+   * Override DatabaseSchema::addField().
+   *
+   * @status complete
+   */
+  public function addField($table, $field, $spec, $new_keys = array()) {
+    if (!$this->tableExists($table)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot add field %table.%field: table doesn't exist.", array('%field' => $field, '%table' => $table)));
+    }
+    if ($this->fieldExists($table, $field)) {
+      throw new DatabaseSchemaObjectExistsException(t("Cannot add field %table.%field: field already exists.", array('%field' => $field, '%table' => $table)));
+    }
+
+    // If the field is declared NOT NULL, we have to first create it NULL insert
+    // the initial data then switch to NOT NULL.
+    if (!empty($spec['not null']) && !isset($spec['default'])) {
+      $fixnull = TRUE;
+      $spec['not null'] = FALSE;
+    }
+
+    // Create the field.
+    $query = 'ALTER TABLE {' . $table . '} ADD ';
+    $query .= $this->createFieldSql($table, $field, $this->processField($spec));
+    $this->connection->query($query);
+
+    // Reset the blob cache.
+    $this->additionalColumnInformation = NULL;
+
+    // Load the initial data.
+    if (isset($spec['initial'])) {
+      $this->connection->update($table)
+        ->fields(array($field => $spec['initial']))
+        ->execute();
+    }
+
+    // Switch to NOT NULL now.
+    if (!empty($fixnull)) {
+      $spec['not null'] = TRUE;
+      $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN ' . $this->createFieldSql($table, $field, $this->processField($spec), TRUE));
+    }
+
+    // Add the new keys.
+    if (isset($new_keys)) {
+      $this->recreateTableKeys($table, $new_keys);
+    }
+  }
+
+  /**
+   * Override DatabaseSchema::changeField().
+   *
+   * @status complete
+   */
+  public function changeField($table, $field, $field_new, $spec, $new_keys = array()) {
+    if (!$this->fieldExists($table, $field)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot change the definition of field %table.%name: field doesn't exist.", array('%table' => $table, '%name' => $field)));
+    }
+    if (($field != $field_new) && $this->fieldExists($table, $field_new)) {
+      throw new DatabaseSchemaObjectExistsException(t("Cannot rename field %table.%name to %name_new: target field already exists.", array('%table' => $table, '%name' => $field, '%name_new' => $field_new)));
+    }
+
+    // SQL Server supports transactional DDL, so we can just start a transaction
+    // here and pray for the best.
+    $transaction = $this->connection->startTransaction();
+
+    // Introspect the schema and save the current primary key if the column
+    // we are modifying is part of it.
+    $primary_key_sql = $this->introspectPrimaryKey($table, $field);
+
+    // If there is a generated unique key for this field, we will need to
+    // add it back in when we are done
+    $unique_key = $this->uniqueKeyExists($table, $field);
+
+    // Drop the related objects.
+    $this->dropFieldRelatedObjects($table, $field);
+
+    // Start by renaming the current column.
+    $this->connection->query('EXEC sp_rename :old, :new, :type', array(
+      ':old' => $this->connection->prefixTables('{' . $table . '}.' . $field),
+      ':new' => $field . '_old',
+      ':type' => 'COLUMN',
+    ));
+
+    // If the field is declared NOT NULL, we have to first create it NULL insert
+    // the initial data then switch to NOT NULL.
+    if (!empty($spec['not null']) && !isset($spec['default'])) {
+      $fixnull = TRUE;
+      $spec['not null'] = FALSE;
+    }
+
+    // Create a new field.
+    $this->addField($table, $field_new, $spec);
+
+    // Migrate the data over.
+    // Explicitly cast the old value to the new value to avoid conversion errors.
+    $field_spec = $this->processField($spec);
+    $this->connection->query('UPDATE [{' . $table . '}] SET [' . $field_new . '] = CAST([' . $field . '_old] AS ' . $field_spec['sqlsrv_type'] . ')');
+
+    // Switch to NOT NULL now.
+    if (!empty($fixnull)) {
+      $spec['not null'] = TRUE;
+      $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN ' . $this->createFieldSql($table, $field_new, $this->processField($spec), TRUE));
+    }
+
+    // Recreate the primary key.
+    if ($primary_key_sql) {
+      $this->recreatePrimaryKey($table, $primary_key_sql);
+    }
+    if ($unique_key) {
+      $fields = array();
+      $fields[] = $field;
+      $this->addUniqueKey($table, $field, $fields);
+    }
+
+    // Drop the old field.
+    $this->dropField($table, $field . '_old');
+
+    // Add the new keys.
+    if (isset($new_keys)) {
+      $this->recreateTableKeys($table, $new_keys);
+    }
+  }
+
+  protected function introspectPrimaryKey($table, $field) {
+    // Fetch the list of columns participating to the primary key.
+    $result = $this->connection->query('SELECT i.name, ic.is_descending_key, c.name column_name
+      FROM sys.columns c
+       INNER JOIN sys.index_columns ic ON ic.object_id = c.object_id AND ic.column_id = c.column_id
+       INNER JOIN sys.indexes i ON i.object_id = ic.object_id AND i.index_id = ic.index_id
+      WHERE i.object_id = OBJECT_ID(:table) AND i.is_primary_key = 1 ORDER BY ic.key_ordinal', array(
+      ':table' => $this->connection->prefixTables('{' . $table . '}'),
+    ));
+    $columns = array();
+    $valid = FALSE;
+    foreach ($result as $column) {
+      if ($column->column_name == $field) {
+        $valid = TRUE;
+      }
+      $columns[] = '[' . $column->column_name . ']' . ($column->is_descending_key ? ' DESC' : '');
+    }
+    if ($valid) {
+      return 'ADD CONSTRAINT [' . $column->name . '] PRIMARY KEY CLUSTERED (' . implode(', ', $columns) . ')';
+    }
+  }
+
+  protected function recreatePrimaryKey($table, $primary_key_sql) {
+    // Drop the existing primary key if exists.
+    if ($existing_primary_key = $this->primaryKeyName($table)) {
+      $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT [' . $existing_primary_key . ']');
+    }
+
+    $this->connection->query('ALTER TABLE [{' . $table . '}] ' . $primary_key_sql);
+  }
+
+  /**
+   * Re-create keys associated to a table.
+   */
+  protected function recreateTableKeys($table, $new_keys) {
+    if (isset($new_keys['primary key'])) {
+      $this->addPrimaryKey($table, $new_keys['primary key']);
+    }
+    if (isset($new_keys['unique keys'])) {
+      foreach ($new_keys['unique keys'] as $name => $fields) {
+        $this->addUniqueKey($table, $name, $fields);
+      }
+    }
+    if (isset($new_keys['indexes'])) {
+      foreach ($new_keys['indexes'] as $name => $fields) {
+        $this->addIndex($table, $name, $fields);
+      }
+    }
+  }
+
+  /**
+   * Override DatabaseSchema::dropField().
+   *
+   * @status complete
+   */
+  public function dropField($table, $field) {
+    if (!$this->fieldExists($table, $field)) {
+      return FALSE;
+    }
+
+    // Drop the related objects.
+    $this->dropFieldRelatedObjects($table, $field);
+
+    $this->connection->query('ALTER TABLE {' . $table . '} DROP COLUMN ' . $field);
+    return TRUE;
+  }
+
+  /**
+   * Drop the related objects of a column (indexes, constraints, etc.).
+   *
+   * @status complete
+   */
+  protected function dropFieldRelatedObjects($table, $field) {
+    // Fetch the list of indexes referencing this column.
+    $indexes = $this->connection->query('SELECT DISTINCT i.name FROM sys.columns c INNER JOIN sys.index_columns ic ON ic.object_id = c.object_id AND ic.column_id = c.column_id INNER JOIN sys.indexes i ON i.object_id = ic.object_id AND i.index_id = ic.index_id WHERE i.is_primary_key = 0 AND i.is_unique_constraint = 0 AND c.object_id = OBJECT_ID(:table) AND c.name = :name', array(
+      ':table' => $this->connection->prefixTables('{' . $table . '}'),
+      ':name' => $field,
+    ));
+    foreach ($indexes as $index) {
+      $this->connection->query('DROP INDEX [' . $index->name . '] ON [{' . $table . '}]');
+    }
+
+    // Fetch the list of check constraints referencing this column.
+    $constraints = $this->connection->query('SELECT DISTINCT cc.name FROM sys.columns c INNER JOIN sys.check_constraints cc ON cc.parent_object_id = c.object_id AND cc.parent_column_id = c.column_id WHERE c.object_id = OBJECT_ID(:table) AND c.name = :name', array(
+      ':table' => $this->connection->prefixTables('{' . $table . '}'),
+      ':name' => $field,
+    ));
+    foreach ($constraints as $constraint) {
+      $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT [' . $constraint->name . ']');
+    }
+
+    // Fetch the list of default constraints referencing this column.
+    $constraints = $this->connection->query('SELECT DISTINCT dc.name FROM sys.columns c INNER JOIN sys.default_constraints dc ON dc.parent_object_id = c.object_id AND dc.parent_column_id = c.column_id WHERE c.object_id = OBJECT_ID(:table) AND c.name = :name', array(
+      ':table' => $this->connection->prefixTables('{' . $table . '}'),
+      ':name' => $field,
+    ));
+    foreach ($constraints as $constraint) {
+      $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT [' . $constraint->name . ']');
+    }
+
+    // Drop any indexes on related computed columns when we have some.
+    if ($this->uniqueKeyExists($table, $field)) {
+      $this->dropUniqueKey($table, $field);
+    }
+
+  }
+
+  /**
+   * Override DatabaseSchema::fieldSetDefault().
+   *
+   * @status complete
+   */
+  public function fieldSetDefault($table, $field, $default) {
+    if (!$this->fieldExists($table, $field)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot set default value of field %table.%field: field doesn't exist.", array('%table' => $table, '%field' => $field)));
+    }
+
+    if ($default === NULL) {
+      $default = 'NULL';
+    }
+    elseif (is_string($default)) {
+      $default = "'" . addslashes($spec['default']) . "'";
+    }
+
+    // Try to remove any existing default first.
+    try { $this->fieldSetNoDefault($table, $field); } catch (Exception $e) {}
+
+    // Create the new default.
+    $this->connection->query('ALTER TABLE [{' . $table . '}] ADD CONSTRAINT {' . $table . '}_' . $field . '_df DEFAULT ' . $default . ' FOR [' . $field . ']');
+  }
+
+  /**
+   * Override DatabaseSchema::fieldSetNoDefault().
+   *
+   * @status complete
+   */
+  public function fieldSetNoDefault($table, $field) {
+    if (!$this->fieldExists($table, $field)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot remove default value of field %table.%field: field doesn't exist.", array('%table' => $table, '%field' => $field)));
+    }
+
+    $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT {' . $table . '}_' . $field . '_df');
+  }
+
+  /**
+   * Override DatabaseSchema::addPrimaryKey().
+   *
+   * @status tested
+   */
+  public function addPrimaryKey($table, $fields) {
+    if (!$this->tableExists($table)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot add primary key to table %table: table doesn't exist.", array('%table' => $table)));
+    }
+
+    if ($primary_key_name = $this->primaryKeyName($table)) {
+      if ($this->isTechnicalPrimaryKey($primary_key_name)) {
+        // Destroy the existing technical primary key.
+        $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT [' . $primary_key_name . ']');
+        $this->cleanUpTechnicalPrimaryColumn($table);
+      }
+      else {
+        throw new DatabaseSchemaObjectExistsException(t("Cannot add primary key to table %table: primary key already exists.", array('%table' => $table)));
+      }
+    }
+
+    $this->connection->query('ALTER TABLE [{' . $table . '}] ADD CONSTRAINT {' . $table . '_pkey} PRIMARY KEY (' . $this->createKeySql($fields) . ')');
+    return TRUE;
+  }
+
+  /**
+   * Override DatabaseSchema::dropPrimaryKey().
+   *
+   * @status tested
+   */
+  public function dropPrimaryKey($table) {
+    if (!$this->primaryKeyName($table)) {
+      return FALSE;
+    }
+
+    $this->connection->query('ALTER TABLE [{' . $table . '}] DROP CONSTRAINT {' . $table . '_pkey}');
+
+    $this->createTechnicalPrimaryColumn($table);
+    $this->connection->query('ALTER TABLE [{' . $table . '}] ADD CONSTRAINT {' . $table . '}_pkey_technical PRIMARY KEY CLUSTERED (__pk)');
+
+    return TRUE;
+  }
+
+  /**
+   * Return the name of the primary key of a table if it exists.
+   */
+  protected function primaryKeyName($table) {
+    $table = $this->connection->prefixTables('{' . $table . '}');
+    return $this->connection->query('SELECT name FROM sys.key_constraints WHERE parent_object_id = OBJECT_ID(:table) AND type = :type', array(
+      ':table' => $table,
+      ':type' => 'PK',
+    ))->fetchField();
+  }
+
+  /**
+   * Check if a key is a technical primary key.
+   */
+  protected function isTechnicalPrimaryKey($key_name) {
+    return $key_name && preg_match('/_pkey_technical$/', $key_name);
+  }
+
+  /**
+   * Add a primary column to the table.
+   */
+  protected function createTechnicalPrimaryColumn($table) {
+    if (!$this->fieldExists($table, '__pk')) {
+      $this->connection->query('ALTER TABLE {' . $table . '} ADD __pk UNIQUEIDENTIFIER DEFAULT NEWID() NOT NULL');
+    }
+  }
+
+  /**
+   * Try to clean up the technical primary column if possible.
+   */
+  protected function cleanUpTechnicalPrimaryColumn($table) {
+    // Get the number of remaining unique indexes on the table, and prune
+    // the technical primary column if possible.
+    $unique_indexes = $this->connection->query('SELECT COUNT(*) FROM sys.indexes WHERE object_id = OBJECT_ID(:table) AND is_unique = 1', array(':table' => $this->connection->prefixTables('{' . $table . '}')))->fetchField();
+    if (!$unique_indexes && !$this->isTechnicalPrimaryKey($this->primaryKeyName($table))) {
+      $this->dropField($table, '__pk');
+    }
+  }
+
+  /**
+   * Override DatabaseSchema::addUniqueKey().
+   *
+   * @status tested
+   */
+  public function addUniqueKey($table, $name, $fields) {
+    if (!$this->tableExists($table)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot add unique key %name to table %table: table doesn't exist.", array('%table' => $table, '%name' => $name)));
+    }
+    if ($this->uniqueKeyExists($table, $name)) {
+      throw new DatabaseSchemaObjectExistsException(t("Cannot add unique key %name to table %table: unique key already exists.", array('%table' => $table, '%name' => $name)));
+    }
+
+    $this->createTechnicalPrimaryColumn($table);
+
+    // Then, build a expression based on the columns.
+    $column_expression = array();
+    foreach ($fields as $field) {
+      if (is_array($field)) {
+        $column_expression[] = 'SUBSTRING(CAST(' . $field[0] . ' AS varbinary(max)),1,' . $field[1] . ')';
+      }
+      else {
+        $column_expression[] = 'CAST(' . $field . ' AS varbinary(max))';
+      }
+    }
+    $column_expression = implode(' + ', $column_expression);
+
+    // Build a computed column based on the expression that replaces NULL
+    // values with the globally unique identifier generated previously.
+    // This is (very) unlikely to result in a collision with any actual value
+    // in the columns of the unique key.
+    $this->connection->query('ALTER TABLE {' . $table . '} ADD __unique_' . $name . " AS CAST(HashBytes('MD4', COALESCE(" . $column_expression . ", CAST(__pk AS varbinary(max)))) AS varbinary(16))");
+    $this->connection->query('CREATE UNIQUE INDEX ' . $name . '_unique ON [{' . $table . '}] (__unique_' . $name . ')');
+  }
+
+  /**
+   * Override DatabaseSchema::dropUniqueKey().
+   *
+   * @status tested
+   */
+  public function dropUniqueKey($table, $name) {
+    if (!$this->uniqueKeyExists($table, $name)) {
+      return FALSE;
+    }
+
+    $this->connection->query('DROP INDEX ' . $name . '_unique ON [{' . $table . '}]');
+    $this->connection->query('ALTER TABLE [{' . $table . '}] DROP COLUMN __unique_' . $name);
+
+    // Try to clean-up the technical primary key if possible.
+    $this->cleanUpTechnicalPrimaryColumn($table);
+  }
+
+  /**
+   * Find if an unique key exists.
+   *
+   * @status tested
+   */
+  protected function uniqueKeyExists($table, $name) {
+    $table = $this->connection->prefixTables('{' . $table . '}');
+    return (bool) $this->connection->query('SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(:table) AND name = :name', array(
+      ':table' => $table,
+      ':name' => $name . '_unique',
+    ))->fetchField();
+  }
+
+  /**
+   * Override DatabaseSchema::addIndex().
+   *
+   * @status tested
+   */
+  public function addIndex($table, $name, $fields) {
+    if (!$this->tableExists($table)) {
+      throw new DatabaseSchemaObjectDoesNotExistException(t("Cannot add index %name to table %table: table doesn't exist.", array('%table' => $table, '%name' => $name)));
+    }
+    if ($this->indexExists($table, $name)) {
+      throw new DatabaseSchemaObjectExistsException(t("Cannot add index %name to table %table: index already exists.", array('%table' => $table, '%name' => $name)));
+    }
+
+    $this->connection->query($this->createIndexSql($table, $name, $fields));
+  }
+
+  /**
+   * Override DatabaseSchema::dropIndex().
+   *
+   * @status tested
+   */
+  public function dropIndex($table, $name) {
+    if (!$this->indexExists($table, $name)) {
+      return FALSE;
+    }
+
+    $this->connection->query('DROP INDEX ' . $name . '_idx ON [{' . $table . '}]');
+    return TRUE;
+  }
+
+  /**
+   * Override DatabaseSchema::indexExists().
+   *
+   * @status tested
+   */
+  public function indexExists($table, $name) {
+    $table = $this->connection->prefixTables('{' . $table . '}');
+    return (bool) $this->connection->query('SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(:table) AND name = :name', array(
+      ':table' => $table,
+      ':name' => $name . '_idx'
+    ))->fetchField();
+  }
+}
+
+/**
+ * @} End of "ingroup schemaapi".
+ */
diff --git a/includes/database/sqlsrv/select.inc b/includes/database/sqlsrv/select.inc
new file mode 100755
index 0000000..6c056f2
--- /dev/null
+++ b/includes/database/sqlsrv/select.inc
@@ -0,0 +1,190 @@
+<?php
+
+class SelectQuery_sqlsrv extends SelectQuery {
+
+  /**
+   * Override for SelectQuery::preExecute().
+   *
+   * Ensure that all the fields in ORDER BY and GROUP BY are part of the
+   * main query.
+   */
+  public function preExecute(SelectQueryInterface $query = NULL) {
+    // If no query object is passed in, use $this.
+    if (!isset($query)) {
+     $query = $this;
+    }
+
+    // Only execute this once.
+    if ($this->isPrepared()) {
+     return TRUE;
+    }
+
+    // Execute standard pre-execution first.
+    parent::preExecute($query);
+
+    if ($this->distinct || $this->group) {
+      // When the query is DISTINCT or contains GROUP BY fields, all the fields
+      // in the GROUP BY and ORDER BY clauses must appear in the returned
+      // columns.
+      $columns = $this->order + array_flip($this->group);
+      $counter = 0;
+      foreach ($columns as $field => $dummy) {
+        if (!isset($this->fields[$field]) && !isset($this->expressions[$field])) {
+          $alias = '_field_' . ($counter++);
+          $this->addExpression($field, $alias);
+          $this->queryOptions['sqlsrv_drop_columns'][] = $alias;
+        }
+      }
+
+      // More over, GROUP BY columns cannot use aliases, so expand them to
+      // their full expressions.
+      foreach ($this->group as $key => &$group_field) {
+        // Expand an alias on a field.
+        if (isset($this->fields[$group_field])) {
+          $field = $this->fields[$group_field];
+          $group_field = (isset($field['table']) ? $this->connection->escapeTable($field['table']) . '.' : '') . $this->connection->escapeField($field['field']);
+        }
+        // Expand an alias on an expression.
+        else if (isset($this->expressions[$group_field])) {
+          $expression = $this->expressions[$group_field];
+          $group_field = $expression['expression'];
+        }
+      }
+    }
+
+    return $this->prepared;
+  }
+
+  /**
+   * Override for SelectQuery::compile().
+   *
+   * Detect when this query is prepared for use in a sub-query.
+   */
+  public function compile(DatabaseConnection $connection, QueryPlaceholderInterface $queryPlaceholder) {
+    $this->inSubQuery = $queryPlaceholder != $this;
+    return parent::compile($connection, $queryPlaceholder);
+  }
+
+  public function __toString() {
+    // For convenience, we compile the query ourselves if the caller forgot
+    // to do it. This allows constructs like "(string) $query" to work. When
+    // the query will be executed, it will be recompiled using the proper
+    // placeholder generator anyway.
+    if (!$this->compiled()) {
+      $this->compile($this->connection, $this);
+    }
+  
+    // Create a sanitized comment string to prepend to the query.
+    $comments = $this->connection->makeComment($this->comments);
+
+    // SELECT
+    $query = $comments . 'SELECT ';
+    if ($this->distinct) {
+      $query .= 'DISTINCT ';
+    }
+
+    // FIELDS and EXPRESSIONS
+    $fields = array();
+    foreach ($this->tables as $alias => $table) {
+      if (!empty($table['all_fields'])) {
+        $fields[] = $this->connection->escapeTable($alias) . '.*';
+      }
+    }
+    foreach ($this->fields as $alias => $field) {
+      // Always use the AS keyword for field aliases, as some
+      // databases require it (e.g., PostgreSQL).
+      $fields[] = (isset($field['table']) ? $this->connection->escapeTable($field['table']) . '.' : '') . $this->connection->escapeField($field['field']) . ' AS ' . $this->connection->escapeField($field['alias']);
+    }
+    foreach ($this->expressions as $alias => $expression) {
+      $fields[] = $expression['expression'] . ' AS ' . $expression['alias'];
+    }
+    $query .= implode(', ', $fields);
+
+    // FROM - We presume all queries have a FROM, as any query that doesn't won't need the query builder anyway.
+    $query .= "\nFROM ";
+    foreach ($this->tables as $alias => $table) {
+      $query .= "\n";
+      if (isset($table['join type'])) {
+        $query .= $table['join type'] . ' JOIN ';
+      }
+
+      // If the table is a subquery, compile it and integrate it into this query.
+      if ($table['table'] instanceof SelectQueryInterface) {
+        // Run preparation steps on this sub-query before converting to string.
+        $subquery = $table['table'];
+        $subquery->preExecute();
+        $table_string = '(' . (string) $subquery . ')';
+      }
+      else {
+        $table_string = '{' . $this->connection->escapeTable($table['table']) . '}';
+      }
+
+      // Don't use the AS keyword for table aliases, as some
+      // databases don't support it (e.g., Oracle).
+      $query .=  $table_string . ' ' . $this->connection->escapeTable($table['alias']);
+
+      if (!empty($table['condition'])) {
+        $query .= ' ON ' . $table['condition'];
+      }
+    }
+
+    // WHERE
+    if (count($this->where)) {
+      // There is an implicit string cast on $this->condition.
+      $query .= "\nWHERE ( " . $this->where . " )";
+    }
+
+    // GROUP BY
+    if ($this->group) {
+      $query .= "\nGROUP BY " . implode(', ', $this->group);
+    }
+
+    // HAVING
+    if (count($this->having)) {
+      // There is an implicit string cast on $this->having.
+      $query .= "\nHAVING " . $this->having;
+    }
+
+    // ORDER BY
+    // The ORDER BY clause is invalid in views, inline functions, derived
+    // tables, subqueries, and common table expressions, unless TOP or FOR XML
+    // is also specified.
+    if ($this->order && (empty($this->inSubQuery) || !empty($this->range))) {
+      $query .= "\nORDER BY ";
+      $fields = array();
+      foreach ($this->order as $field => $direction) {
+        $fields[] = $field . ' ' . $direction;
+      }
+      $query .= implode(', ', $fields);
+    }
+
+    // RANGE
+    if (!empty($this->range)) {
+      $query = $this->connection->addRangeToQuery($query, $this->range['start'], $this->range['length']);
+    }
+
+    // UNION is a little odd, as the select queries to combine are passed into
+    // this query, but syntactically they all end up on the same level.
+    if ($this->union) {
+      foreach ($this->union as $union) {
+        $query .= ' ' . $union['type'] . ' ' . (string) $union['query'];
+      }
+    }
+
+    return $query;
+  }
+
+  /**
+   * Override of SelectQuery::orderRandom() for SQL Server.
+   *
+   * It seems that sorting by RAND() doesn't actually work, this is a less then
+   * elegant workaround.
+   *
+   * @status tested
+   */
+  public function orderRandom() {
+    $alias = $this->addExpression('NEWID()', 'random_field');
+    $this->orderBy($alias);
+    return $this;
+  }
+}
\ No newline at end of file
